Partie shell :
--------------

-Afficher une "simili" ligne relative à l'utilisateur et au fichier dans lequel il se trouve
-notamment à l'aide de la commande fflush(stdout) qui force l'affichage

Principe de saisie de commande :
-Saisie d'une commande par l'utilisateur
-Automate de découpage retournant un tableau de chaine de caractères (séparateur 'espace(s)')
-Vérification de l'existence de la commande (argv[0])
-Passage du reste du tableau dans une fonction de vérification :
    -Vérification existence des options/fichiers/...
        //Méthode du Switch --> apparemment marche pas
        executerCMD(char* argv[]){
            switch(argv[0]){
                case "ls" :
                    [...]
                    break;
                case "cd" :
                    [...]
                    break;
            }
        }
    //Seconde méthode de la struct
    -(deuxième solution de Nicolas : informations dans un struct ???)
-Renvoie une erreur si problème à tous les niveaux

-En dernier lieu, tenter de mettre en place la partie réseau du projet -> Création de socket client/serveur

_________________________________________________________________


Partie librairie : 
------------------

-Aider au développement des l'automates à états finis
-Puis partir sur les commandes simples de base comme "ls"
-Définir une commande par défaut permettant de mettre fin au processus "eshelle"

_________________________________________________________________


Interface (à rendre pour le 18/03/2016 avant 23h55)
---------------------------------------------------

Déclaration d'une structure fonction : 
struct fonction
{
  char nom[10];
  pointeur de fonction; 
  (la signature des fonctions exécutant les commandes n'étant pas faites, il nous est actuellement impossible de le déclarer convenablement)  
};

(la modélisation de la structure est encore incertaine)

et d'un tableau de fonction : struct fonction fonctions[18] = {...};
Initialisé avec toutes les fonctions de commande

Après que l'utilisateur ait saisi une commande dans le terminal, un automate à état fini découpe la chaîne de caractères en mots.

Le premier mot est récupéré dans une variable char *cmd(il représente le nom de la commande à exécuter) tandis que les autres dans un tableau de char * (chaque élément du tableau représente un paramètre de la commande et/ou un chemin).

On parcourt alors le tableau de fonction afin de vérifier de l'existence de la commande, et dans le cas où la variable cmd est égale au nom d'une commande, on exécute alors la commande grâce à la fonction associée, appelée via le pointeur de fonction.

La vérification des paramètres se fera dans la fonction appelée. 

(Au départ, nous avions pensé à faire un switch/case afin de vérifier que la commande existe mais dans ce cas là, il nous serait impossible d'appeler la fonction par la suite à cause des librairies dynamique)
